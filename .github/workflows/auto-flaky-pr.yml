name: ðŸ¤– Automated Flaky Test PR

on:
  schedule:
    # Run every 30 minutes
    - cron: '*/30 * * * *'
  workflow_dispatch:
    # Allow manual triggering for testing

env:
  PR_BRANCH: automated-flaky-test-run
  PR_TITLE: "ðŸ¤– Automated flaky test run"

jobs:
  merge-existing-pr:
    name: ðŸ”„ Merge Previous PR
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Merge existing automated PR
        env:
          GH_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
        run: |
          # Find existing automated PR
          pr_number=$(gh pr list --label "automated" --json number --jq '.[0].number // empty')

          if [ -n "$pr_number" ]; then
            echo "ðŸ”„ Found existing automated PR #$pr_number"

            # Get PR branch name
            pr_branch=$(gh pr view $pr_number --json headRefName --jq '.headRefName')
            echo "ðŸ“ PR branch: $pr_branch"

            # Update PR branch with latest main to satisfy branch protection
            echo "ðŸ”„ Updating PR branch with latest main..."
            gh pr checkout $pr_number
            git fetch origin main
            merge_output=$(git merge origin/main --no-edit 2>&1) || {
              echo "âŒ Failed to merge main into PR branch - may have conflicts"
              git merge --abort 2>/dev/null || true
              echo "âš ï¸ Skipping merge due to conflicts, will try again next cycle"
              exit 0
            }

            # Only push if there were actual changes
            if [[ "$merge_output" != *"Already up to date"* ]]; then
              echo "ðŸ“¤ Pushing changes to origin $pr_branch"
              git push origin $pr_branch
            else
              echo "âœ… No changes needed, skipping push (already up to date)"
            fi
            echo "âœ… Updated PR branch with latest main"

            # Check if PR is mergeable (all checks passed)
            pr_status=$(gh pr view $pr_number --json mergeStateStatus --jq '.mergeStateStatus')

            if [ "$pr_status" = "CLEAN" ] || [ "$pr_status" = "UNSTABLE" ]; then
              echo "âœ… PR #$pr_number is ready to merge"
              gh pr merge $pr_number --squash --delete-branch
              echo "ðŸŽ‰ Merged PR #$pr_number"
            else
              echo "â³ PR #$pr_number not ready to merge (status: $pr_status)"

              # Check for failed workflow runs and rerun them
              echo "ðŸ” Checking for failed jobs to rerun..."

              # Get the latest workflow run for this PR
              latest_run_id=$(gh api "repos/${{ github.repository }}/actions/runs" \
                --jq ".workflow_runs[] | select(.head_branch == \"$pr_branch\" and .event == \"pull_request\") | .id" \
                | head -1)

              if [ -n "$latest_run_id" ]; then
                echo "ðŸ“‹ Latest workflow run ID: $latest_run_id"

                # Check if there are any failed jobs in the latest run
                failed_jobs=$(gh api "repos/${{ github.repository }}/actions/runs/$latest_run_id/jobs" \
                  --jq '.jobs[] | select(.conclusion == "failure") | .name' | wc -l)

                if [ "$failed_jobs" -gt 0 ]; then
                  echo "ðŸ”„ Found $failed_jobs failed job(s), triggering retry..."
                  echo "ðŸ”— Original run: https://github.com/${{ github.repository }}/actions/runs/$latest_run_id"

                  # Trigger the retry workflow
                  gh workflow run retry.yml --field run_id=$latest_run_id

                  echo "âœ… Retry workflow triggered for failed jobs"
                  echo "ðŸ’¡ Will check merge status again in next cycle"
                else
                  echo "â„¹ï¸ No failed jobs found - tests may still be running"
                  echo "ðŸ’¡ Branch updated - will check next cycle"
                fi
              else
                echo "â„¹ï¸ No workflow runs found for this PR branch"
                echo "ðŸ’¡ Branch updated - tests may be starting, will check next cycle"
              fi
            fi
          else
            echo "ðŸ“ No existing automated PR found"
          fi

  create-flaky-pr:
    name: ðŸŽ² Create New Automated Flaky Test PR
    needs: merge-existing-pr
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        ref: main
        token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

    - name: Configure Git
      run: |
        git config --global user.name "flaky-test-bot"
        git config --global user.email "flaky-test-bot@users.noreply.github.com"

    - name: Read current run count
      id: read_count
      run: |
        if [ -f runs.txt ]; then
          CURRENT_COUNT=$(cat runs.txt)
        else
          CURRENT_COUNT=0
        fi
        NEW_COUNT=$((CURRENT_COUNT + 1))
        echo "current=$CURRENT_COUNT" >> $GITHUB_OUTPUT
        echo "new=$NEW_COUNT" >> $GITHUB_OUTPUT
        echo "ðŸ“Š Current run count: $CURRENT_COUNT"
        echo "ðŸ“ˆ New run count: $NEW_COUNT"

    - name: Update runs.txt
      run: |
        echo "${{ steps.read_count.outputs.new }}" > runs.txt
        echo "ðŸ“ Updated runs.txt to: $(cat runs.txt)"

    - name: Create timestamp for PR
      id: timestamp
      run: |
        TIMESTAMP=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
        echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT
        echo "ðŸ•’ Timestamp: $TIMESTAMP"


    - name: Create Pull Request
      uses: peter-evans/create-pull-request@v6
      with:
        token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
        commit-message: "ðŸ¤– Automated flaky test run #${{ steps.read_count.outputs.new }}"
        title: "${{ env.PR_TITLE }} #${{ steps.read_count.outputs.new }}"
        body: |
          ## ðŸ¤– Automated Flaky Test Demonstration

          **Run #${{ steps.read_count.outputs.new }}** - ${{ steps.timestamp.outputs.timestamp }}

          This automated PR demonstrates:

          ### ðŸŽ¯ Flaky Test Behavior
          - Tests have **70%, 80%, and 90%** pass rates
          - Simulates real-world test flakiness
          - Shows importance of retry strategies

          ### ðŸ”„ Manual Retry Mechanism
          - Failed tests trigger manual retry workflow automatically
          - Each retry creates a **separate workflow run** for better tracking
          - Uses `workflow_dispatch` with PERSONAL_ACCESS_TOKEN for triggering

          ### ðŸ¤– Automation Features
          - **Hourly schedule**: Creates PR every hour
          - **Auto-merge**: Merges when tests pass and checks are clean
          - **Run tracking**: Updates `runs.txt` counter

          ### ðŸ“Š Expected Behavior
          1. âœ… Tests may pass on first try (~50% chance)
          2. ðŸ”„ Or trigger manual retry workflow for better failure tracking
          3. ðŸ“ˆ Each retry creates separate workflow run with clear logs
          4. ðŸŽ‰ Auto-merge when all tests green
          5. ðŸ“ˆ Counter increments for next run

          ### ðŸ“ˆ Data Collection
          This PR is part of ongoing flaky test data collection to analyze:
          - Retry patterns over time
          - Success rates across languages
          - CI/CD resilience strategies

          ---
          *This is run #${{ steps.read_count.outputs.new }} of the automated flaky test demonstration.*
        labels: |
          automated
          flaky-test-demo
          data-collection
        branch: ${{ env.PR_BRANCH }}-${{ steps.read_count.outputs.new }}
        delete-branch: true
